===================================================================================================
Best Practices
===================================================================================================

Crafting a docstring
You've decided to write the world's greatest open-source natural language processing Python package. 
It will revolutionize working with free-form text, the way numpy did for arrays, pandas did for tabular data, and scikit-learn did for machine learning.

The first function you write is count_letter(). It takes a string and a single letter and returns the number of times 
the letter appears in the string. You want the users of your open-source package to be able to understand how this function works easily, 
so you will need to give it a docstring. Build up a Google Style docstring for this function by following these steps.
-------------------------------------------------
Copy the following string and add it as the docstring for the function: Count the number of times `letter` appears in `content`.

# Add a docstring to count_letter()
def count_letter(content, letter):
  """Count the number of times `letter` appears in `content`"""
  if (not isinstance(letter, str)) or len(letter) != 1:
    raise ValueError('`letter` must be a single character string.')
  return len([char for char in content if char == letter])
-------------------------------------------------
Now add the arguments section, using the Google style for docstrings. Use str to indicate a string.

def count_letter(content, letter):
  """Count the number of times `letter` appears in `content`.

  # Add a Google style arguments section
  Args:
    content (str): The string to search.
    letter (str): The letter to search for.
  """
  if (not isinstance(letter, str)) or len(letter) != 1:
    raise ValueError('`letter` must be a single character string.')
  return len([char for char in content if char == letter])
-------------------------------------------------
Add a returns section that informs the user the return value is an int.

def count_letter(content, letter):
  """Count the number of times `letter` appears in `content`.

  Args:
    content (str): The string to search.
    letter (str): The letter to search for.

  # Add a returns section
  Returns:
    int
  """
  if (not isinstance(letter, str)) or len(letter) != 1:
    raise ValueError('"letter" must be a single character string.')
  return len([char for char in content if char == letter])
-------------------------------------------------
Finally, add some information about the ValueError that gets raised when the arguments aren't correct.

def count_letter(content, letter):
  """Count the number of times `letter` appears in `content`.

  Args:
    content (str): The string to search.
    letter (str): The letter to search for.

  Returns:
    int

  # Add a section detailing what errors might be raised
  Raises:
    ValueError : If `letter` is not a one-character string.
  """
  if (not isinstance(letter, str)) or len(letter) != 1:
    raise ValueError('`letter` must be a single character string.')
  return len([char for char in content if char == letter])
-------------------------------------------------
Retrieving docstrings
You and a group of friends are working on building an amazing new Python IDE (integrated development environment -- like PyCharm, Spyder, 
Eclipse, Visual Studio, etc.). The team wants to add a feature that displays a tooltip with a function's docstring whenever the user starts 
typing the function name. That way, the user doesn't have to go elsewhere to look up the documentation for the function they are trying to use. 
You've been asked to complete the build_tooltip() function that retrieves a docstring from an arbitrary function.

You will be reusing the count_letter() function that you developed in the last exercise to show that we can properly extract its docstring.
-------------------------------------------------
Begin by getting the docstring for the function count_letter(). Use an attribute of the count_letter() function.

# Get the "count_letter" docstring by using an attribute of the function
docstring = count_letter.__doc__

border = '#' * 28
print('{}\n{}\n{}'.format(border, docstring, border))
-------------------------------------------------
Now use a function from the inspect module to get a better-formatted version of count_letter()'s docstring.

import inspect

# Inspect the count_letter() function to get its docstring
docstring = inspect.getdoc(count_letter)

border = '#' * 28
print('{}\n{}\n{}'.format(border, docstring, border))
-------------------------------------------------
Now create a build_tooltip() function that can extract the docstring from any function that we pass to it.

import inspect

def build_tooltip(function):
  """Create a tooltip for any function that shows the
  function's docstring.

  Args:
    function (callable): The function we want a tooltip for.

  Returns:
    str
  """
  # Get the docstring for the "function" argument by using inspect
  docstring = inspect.getdoc(function)
  border = '#' * 28
  return '{}\n{}\n{}'.format(border, docstring, border)

print(build_tooltip(count_letter))
print(build_tooltip(range))
print(build_tooltip(print))
-------------------------------------------------
Extract a function
While developing a model to predict college graduations, you wrote the code below to get the z-scores of students' yearly GPAs 
(z-scores indicate standard deviation from the mean). Now you're ready to turn it into a production-quality system, 
so you need to do something about the repetition. Writing a function to calculate z-scores would improve it.

# Standardize the GPAs for each year
df['y1_z'] = (df.y1_gpa - df.y1_gpa.mean()) / df.y1_gpa.std()
df['y2_z'] = (df.y2_gpa - df.y2_gpa.mean()) / df.y2_gpa.std()
df['y3_z'] = (df.y3_gpa - df.y3_gpa.mean()) / df.y3_gpa.std()
df['y4_z'] = (df.y4_gpa - df.y4_gpa.mean()) / df.y4_gpa.std()
Note: df is a pandas DataFrame where each row is a student with 4 columns of yearly student GPAs: y1_gpa, y2_gpa, y3_gpa, y4_gpa.
-------------------------------------------------
Finish the function so that it returns the z-scores of a column.
Use the function to calculate the z-scores for each year (df['y1_z'], df['y2_z'], etc.) from the raw GPA scores (df.y1_gpa, df.y2_gpa, etc.).

def standardize(column):
  """Standardize the values in a column.

  Args:
    column (pandas Series): The data to standardize.

  Returns:
    pandas Series: the values as z-scores
  """
  # Finish the function so that it returns the z-scores
  z_score = (df.column - df.column.mean()) / df.column.std()
  return z_score

# Use the standardize() function to calculate the z-scores
df['y1_z'] = (df.y1_gpa - df.y1_gpa.mean()) / df.y1_gpa.std()
df['y2_z'] = (df.y2_gpa - df.y2_gpa.mean()) / df.y2_gpa.std()
df['y3_z'] = (df.y3_gpa - df.y3_gpa.mean()) / df.y3_gpa.std()
df['y4_z'] = (df.y4_gpa - df.y4_gpa.mean()) / df.y4_gpa.std()
-------------------------------------------------
Split up a function
Another engineer on your team has written this function to calculate the mean and median of a sorted list. 
You want to show them how to split it into two simpler functions: mean() and median()

def mean_and_median(values):
  """Get the mean and median of a sorted list of `values`

  Args:
    values (iterable of float): A list of numbers

  Returns:
    tuple (float, float): The mean and median
  """
  mean = sum(values) / len(values)
  midpoint = int(len(values) / 2)
  if len(values) % 2 == 0:
    median = (values[midpoint - 1] + values[midpoint]) / 2
  else:
    median = values[midpoint]

  return mean, median

-------------------------------------------------
Write the mean() function.

def mean(values):
  """Get the mean of a sorted list of values

  Args:
    values (iterable of float): A list of numbers

  Returns:
    float
  """
  # Write the mean() function
  mean = sum(values) / len(values)
  return mean
-------------------------------------------------
Write the median() function.

def median(values):
  """Get the median of a sorted list of values

  Args:
    values (iterable of float): A list of numbers

  Returns:
    float
  """
  # Write the median() function
  midpoint = int(len(values) / 2)
  if len(values) % 2 == 0:
    median = (values[midpoint - 1] + values[midpoint]) / 2
  else:
    median = values[midpoint]
  return median
-------------------------------------------------
Best practice for default arguments
One of your co-workers (who obviously didn't take this course) has written this function for adding a column to a pandas DataFrame. 
Unfortunately, they used a mutable variable as a default argument value! 
Please show them a better way to do this so that they don't get unexpected behavior.

def add_column(values, df=pandas.DataFrame()):
  """Add a column of `values` to a DataFrame `df`.
  The column will be named "col_<n>" where "n" is
  the numerical index of the column.

  Args:
    values (iterable): The values of the new column
    df (DataFrame, optional): The DataFrame to update.
      If no DataFrame is passed, one is created by default.

  Returns:
    DataFrame
  """
  df['col_{}'.format(len(df.columns))] = values
  return df
-------------------------------------------------
Change the default value of df to an immutable value to follow best practices.
Update the code of the function so that a new DataFrame is created if the caller didn't pass one.

# Use an immutable variable for the default argument
def better_add_column(values, df=None):
  """Add a column of `values` to a DataFrame `df`.
  The column will be named "col_<n>" where "n" is
  the numerical index of the column.

  Args:
    values (iterable): The values of the new column
    df (DataFrame, optional): The DataFrame to update.
      If no DataFrame is passed, one is created by default.

  Returns:
    DataFrame
  """
  # Update the function to create a default DataFrame
  if df is None:
    df = pandas.DataFrame()
  df['col_{}'.format(len(df.columns))] = values
  return df

===================================================================================================
Context Managers
===================================================================================================

The number of cats
You are working on a natural language processing project to determine what makes great writers so great. 
Your current hypothesis is that great writers talk about cats a lot. To prove it, 
you want to count the number of times the word "cat" appears in "Alice's Adventures in Wonderland" by Lewis Carroll. 
You have already downloaded a text file, alice.txt, with the entire contents of this great book.
-------------------------------------------------
Use the open() context manager to open alice.txt and assign the file to the file variable.

# Open "alice.txt" and assign the file to "file"
with open('alice.txt') as file:
  text = file.read()

n = 0
for word in text.split():
  if word.lower() in ['cat', 'cats']:
    n += 1

print('Lewis Carroll uses the word "cat" {} times'.format(n))
-------------------------------------------------
The speed of cats
You're working on a new web service that processes Instagram feeds to identify which pictures contain cats 
(don't ask why -- it's the internet). The code that processes the data is slower than you would like it to be, 
so you are working on tuning it up to run faster. Given an image, image, you have two functions that can process it:

process_with_numpy(image)
process_with_pytorch(image)
Your colleague wrote a context manager, timer(), that will print out how long the code inside the context block takes to run. 
She is suggesting you use it to see which of the two options is faster. Time each function to determine which one to use in your web service.
-------------------------------------------------
Use the timer() context manager to time how long process_with_numpy(image) takes to run.
Use the timer() context manager to time how long process_with_pytorch(image) takes to run.

image = get_image_from_instagram()

# Time how long process_with_numpy(image) takes to run
with timer():
  print('Numpy version')
  process_with_numpy(image)

# Time how long process_with_pytorch(image) takes to run
with timer():
  print('Pytorch version')
  process_with_pytorch(image)
-------------------------------------------------
The timer() context manager
A colleague of yours is working on a web service that processes Instagram photos. 
Customers are complaining that the service takes too long to identify whether or not an image has a cat in it, so your colleague has come to you for help. 
You decide to write a context manager that they can use to time how long their functions take to run.
-------------------------------------------------
Add a decorator from the contextlib module to the timer() function that will make it act like a context manager.
Send control from the timer() function to the context block.

# Add a decorator that will make timer() a context manager
@contextlib.contextmanager
def timer():
  """Time the execution of a context block.

  Yields:
    None
  """
  start = time.time()
  # Send control back to the context block
  yield
  end = time.time()
  print('Elapsed: {:.2f}s'.format(end - start))

with timer():
  print('This should take approximately 0.25 seconds')
  time.sleep(0.25)
-------------------------------------------------
A read-only open() context manager
You have a bunch of data files for your next deep learning project that took you months to collect and clean. 
It would be terrible if you accidentally overwrote one of those files when trying to read it in for training, 
so you decide to create a read-only version of the open() context manager to use in your project.

The regular open() context manager:

takes a filename and a mode ('r' for read, 'w' for write, or 'a' for append)
opens the file for reading, writing, or appending
yields control back to the context, along with a reference to the file
waits for the context to finish
and then closes the file before exiting
Your context manager will do the same thing, except it will only take the filename as an argument and it will only open the file for reading.
-------------------------------------------------
Yield control from open_read_only() to the context block, ensuring that the read_only_file object gets assigned to my_file.
Use read_only_file's .close() method to ensure that you don't leave open files lying around.

@contextlib.contextmanager
def open_read_only(filename):
  """Open a file in read-only mode.

  Args:
    filename (str): The location of the file to read

  Yields:
    file object
  """
  read_only_file = open(filename, mode='r')
  # Yield read_only_file so it can be assigned to my_file
  yield read_only_file
  # Close read_only_file
  read_only_file.close()

with open_read_only('my_file.txt') as my_file:
  print(my_file.read())
-------------------------------------------------
Scraping the NASDAQ
Training neural nets is expensive - invest in NVIDIA! To find the best time to invest, collect stock data.

The context manager stock('NVDA') connects to NASDAQ and return an object that you can use to get the latest price by calling its .price() method. 
You want to connect to stock('NVDA') and record 10 timesteps of price data by writing it to the file NVDA.txt.

You will notice the use of an underscore when iterating over the for loop. If this is confusing to you, don't worry. 
It could easily be replaced with i, if we planned to do something with it, like use it as an index. Since we won't be using it, 
we can use a dummy operator, _, which doesn't use any additional memory.
-------------------------------------------------
Use the stock('NVDA') context manager and assign the result to nvda.
Open a file for writing with open('NVDA.txt', 'w') and assign the file object to f_out so you can record the price over time.

# Use the "stock('NVDA')" context manager
# and assign the result to the variable "nvda"

with stock('NVDA') as nvda:
  # Open "NVDA.txt" for writing as f_out
  with open('NVDA.txt', 'w') as f_out:
    for value in range(10):
      value = nvda.price()
      print('Logging ${:.2f} for NVDA'.format(value))
      f_out.write('{:.2f}\n'.format(value))
-------------------------------------------------
Changing the working directory
You are using an open-source library that lets you train deep neural networks on your data. 
Unfortunately, during training, this library writes out checkpoint models (i.e., models that have been trained on a portion of the data)
to the current working directory. You find that behavior frustrating because you don't want to have to launch the script from the directory 
where the models will be saved.

You decide that one way to fix this is to write a context manager that changes the current working directory, 
lets you build your models, and then resets the working directory to its original location. 
You'll want to be sure that any errors that occur during model training don't prevent you from resetting the working directory to its original location.
-------------------------------------------------
Add a statement that lets you handle any errors that might occur inside the context.
Add a statement that ensures os.chdir(current_dir) will be called, whether there was an error or not.

def in_dir(directory):
  """Change current working directory to `directory`,
  allow the user to run some code, and change back.

  Args:
    directory (str): The path to a directory to work in.
  """
  current_dir = os.getcwd()
  os.chdir(directory)

  # Add code that lets you handle errors
  try:
    yield
  # Ensure the directory is reset,
  # whether there was an error or not
  finally:
    os.chdir(current_dir)

===================================================================================================
Decorators
===================================================================================================

Building a command line data app
You are building a command line tool that lets a user interactively explore a dataset. 
We've defined four functions: mean(), std(), minimum(), and maximum() that users can call to analyze their data. 
Help finish this section of the code so that your users can call any of these functions by typing the function name at the input prompt.

Note: The function get_user_input() in this exercise is a mock version of asking the user to enter a command. 
It randomly returns one of the four function names. In real life, you would ask for input and wait until the user entered a value.
-------------------------------------------------
Add the functions std(), minimum(), and maximum() to the function_map dictionary, like we did with mean().
The name of the function the user wants to call is stored in func_name. Use the dictionary of functions, function_map, 
to call the chosen function and pass data as an argument.

# Add the missing function references to the function map
function_map = {
  'mean': mean,
  'std': std,
  'minimum': minimum,
  'maximum': maximum
}

data = load_data()
print(data)

func_name = get_user_input()

# Call the chosen function and pass "data" as an argument
function_map[func_name](data)
-------------------------------------------------
Reviewing your co-worker's code
Your co-worker is asking you to review some code that they've written and give them some tips on how to get it ready for production. 
You know that having a docstring is considered best practice for maintainable, reusable functions, 
so as a sanity check you decide to use this has_docstring() function on all of their functions.

def has_docstring(func):
  """Check to see if the function 
  `func` has a docstring.

  Args:
    func (callable): A function.

  Returns:
    bool
  """
  return func.__doc__ is not None
-------------------------------------------------
Call has_docstring() on your co-worker's load_and_plot_data() function.

# Call has_docstring() on the load_and_plot_data() function
ok = has_docstring(load_and_plot_data)

if not ok:
  print("load_and_plot_data() doesn't have a docstring!")
else:
  print("load_and_plot_data() looks ok")
-------------------------------------------------
Check if the function as_2D() has a docstring.

# Call has_docstring() on the as_2D() function
ok = has_docstring(as_2D)

if not ok:
  print("as_2D() doesn't have a docstring!")
else:
  print("as_2D() looks ok")
-------------------------------------------------
Check if the function log_product() has a docstring.

# Call has_docstring() on the log_product() function
ok = has_docstring(log_product)

if not ok:
  print("log_product() doesn't have a docstring!")
else:
  print("log_product() looks ok")
-------------------------------------------------
Returning functions for a math game
You are building an educational math game where the player enters a math term, and your program returns a function that matches that term. 
For instance, if the user types "add", your program returns a function that adds two numbers. So far you've only implemented the "add" function. 
Now you want to include a "subtract" function.
-------------------------------------------------
Define the subtract() function. It should take two arguments and return the first argument minus the second argument.

def create_math_function(func_name):
  if func_name == 'add':
    def add(a, b):
      return a + b
    return add
  elif func_name == 'subtract':
    # Define the subtract() function
    def subtract(a, b):
      return a - b
    return subtract
  else:
    print("I don't know that one")
    
add = create_math_function('add')
print('5 + 2 = {}'.format(add(5, 2)))

subtract = create_math_function('subtract')
print('5 - 2 = {}'.format(subtract(5, 2)))
-------------------------------------------------
Modifying variables outside local scope
Sometimes your functions will need to modify a variable that is outside of the local scope of that function. 
While it's generally not best practice to do so, it's still good to know how in case you need to do it. 
Update these functions so they can modify variables that would usually be outside of their scope.
-------------------------------------------------
Add a keyword that lets us update call_count from inside the function.

call_count = 0

def my_function():
  # Use a keyword that lets us update call_count 
  global call_count
  call_count += 1
  
  print("You've called my_function() {} times!".format(
    call_count
  ))
  
for func in range(20):
  my_function()
-------------------------------------------------
Add a keyword that lets us modify file_contents from inside save_contents().

def read_files():
  file_contents = None
  
  def save_contents(filename):
    # Add a keyword that lets us modify file_contents
    nonlocal file_contents
    if file_contents is None:
      file_contents = []
    with open(filename) as fin:
      file_contents.append(fin.read())
      
  for filename in ['1984.txt', 'MobyDick.txt', 'CatsEye.txt']:
    save_contents(filename)
    
  return file_contents

print('\n'.join(read_files()))
-------------------------------------------------
Add a keyword to done in check_is_done() so that wait_until_done() eventually stops looping.

def wait_until_done():
  def check_is_done():
    # Add a keyword so that wait_until_done() 
    # doesn't run forever
    global done
    if random.random() < 0.1:
      done = True
      
  while not done:
    check_is_done()

done = False
wait_until_done()

print('Work done? {}'.format(done))
-------------------------------------------------
Checking for closure
You're teaching your niece how to program in Python, and she is working on returning nested functions. 
She thinks she has written the code correctly, but she is worried that the returned function won't have the necessary information when called. 
Show her that all of the nonlocal variables she needs are in the new function's closure.
-------------------------------------------------
Use an attribute of the my_func() function to show that it has a closure that is not None.

def return_a_func(arg1, arg2):
  def new_func():
    print('arg1 was {}'.format(arg1))
    print('arg2 was {}'.format(arg2))
  return new_func
    
my_func = return_a_func(2, 17)

# Show that my_func()'s closure is not None
print(my_func.__closure__ is not None)
-------------------------------------------------
Show that there are two variables in the closure.

def return_a_func(arg1, arg2):
  def new_func():
    print('arg1 was {}'.format(arg1))
    print('arg2 was {}'.format(arg2))
  return new_func
    
my_func = return_a_func(2, 17)

print(my_func.__closure__ is not None)

# Show that there are two variables in the closure
print(len(my_func.__closure__) == 2)
-------------------------------------------------
Get the values of the variables in the closure so you can show that they are equal to [2, 17], the arguments passed to return_a_func().

def return_a_func(arg1, arg2):
  def new_func():
    print('arg1 was {}'.format(arg1))
    print('arg2 was {}'.format(arg2))
  return new_func
    
my_func = return_a_func(2, 17)

print(my_func.__closure__ is not None)
print(len(my_func.__closure__) == 2)

# Get the values of the variables in the closure
closure_values = [
  my_func.__closure__[i].cell_contents for i in range(2)
]
print(closure_values == [2, 17])
-------------------------------------------------
Closures keep your values safe
You are still helping your niece understand closures. You have written the function get_new_func() that returns a nested function. 
The nested function call_func() calls whatever function was passed to get_new_func(). 
You've also written my_special_function() which simply prints a message that states that you are executing my_special_function().

You want to show your niece that no matter what you do to my_special_function() after passing it to get_new_func(), 
the new function still mimics the behavior of the original my_special_function() because it is in the new function's closure.
-------------------------------------------------
Show that you still get the original message even if you redefine my_special_function() to only print "hello".

def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

new_func = get_new_func(my_special_function)

# Redefine my_special_function() to just print "hello"
def my_special_function():
  print('hello')

new_func()
-------------------------------------------------
Show that even if you delete my_special_function(), you can still call new_func() without any problems.

def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

new_func = get_new_func(my_special_function)

# Delete my_special_function()
del(my_special_function)

new_func()
-------------------------------------------------
Show that you still get the original message even if you overwrite my_special_function() with the new function.

def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

# Overwrite `my_special_function` with the new function
my_special_function = get_new_func(my_special_function)

my_special_function()
-------------------------------------------------
Using decorator syntax
You have written a decorator called print_args that prints out all of the arguments and their values any time a function that it is decorating gets called.
-------------------------------------------------
Decorate my_function() with the print_args() decorator by redefining the my_function variable.

def my_function(a, b, c):
  print(a + b + c)

# Decorate my_function() with the print_args() decorator
my_function = print_args(my_function)

my_function(1, 2, 3)
-------------------------------------------------
Decorate my_function() with the print_args() decorator using decorator syntax.

# Decorate my_function() with the print_args() decorator
@print_args
def my_function(a, b, c):
  print(a + b + c)

my_function(1, 2, 3)
-------------------------------------------------
Defining a decorator
Your buddy has been working on a decorator that prints a "before" message before the decorated function is called and prints an "after" message 
after the decorated function is called. They are having trouble remembering how wrapping the decorated function is supposed to work. 
Help them out by finishing their print_before_and_after() decorator.
-------------------------------------------------
Call the function being decorated and pass it the positional arguments *args.
Return the new decorated function.

def print_before_and_after(func):
  def wrapper(*args):
    print('Before {}'.format(func.__name__))
    # Call the function being decorated with *args
    func(*args)
    print('After {}'.format(func.__name__))
  # Return the nested function
  return wrapper

@print_before_and_after
def multiply(a, b):
  print(a * b)

multiply(5, 10)

===================================================================================================
More on Decorators
===================================================================================================

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------

-------------------------------------------------
